#!/usr/bin/env node
var config = require("../config");
var Queue = require("file-queue").Queue;
var defer = require('promised-io/promise').defer;
var when = require('promised-io/promise').when;
var All = require('promised-io/promise').all;
var Path = require('path');
var fs = require("fs-extra");
var Request = require("request");

console.log("Queue Directory: ", config.get("queueDirectory"));

var queue = new Queue(config.get("queueDirectory"), function(err) {
        if (err) {
                console.log("error: ", err);
                return;
        }
	processQueue(queue);
});

var maxLimit = config.get("indexImportLimits");

process.on('message', function(msg){
	if (msg && msg.type=="start"){
		if (timer) {
			cancelTimeout(timer);
			delete timer;
		}

		processQueue(queue);
	}
});
var timer;

function postDocs(docs,type){
        var defs = [];
        var def = new defer();
        var url = config.get("solr").url + "/"+type+"/update?wt=json&overwrite=false&commit=false";
        console.log("POST URL: ", url, " #docs:", docs.length);
        Request(url, {
                json: true,
                method: "POST",
                headers: { "content-type": "application/json", "accept":"application/json" },
                body: docs
        }, function(err,response,body){
                if (err || body.error){
                        console.log("Error POSTing to : " + type +" - " + ( err||body.error.msg));
                        def.reject(err);
                        return;
                }
             //   console.log("POST RESPONSE BODY: ", JSON.stringify(body));
                def.resolve(true);
        });

        return def.promise;
}

function solrCommit(type){
	var def = new defer();

	Request(config.get("solr").url + "/" + type + "/update?commit=true",{},function(err,response,body){
		if (err) { def.reject(err); return; }
		console.log("COMMIT " + type + " RESPONSE BODY: ", JSON.stringify(body));
		def.resolve(true);
	});
	return def.promise;
}

function processQueue(queue){
	console.log("processQueue");
	queue.length(function(err,length){
		if (length < 1){
			setTimeout(function(){
				processQueue(queue);
			},5000);
		}else{
//			console.log("Processing " + length + " queue items");
		
			queue.tpop(function(err,message,commit,rollback){
				var startTime=new Date();
				if (err) {
					console.log("error popping message item: ", err);
					return;
				}
				if (!message){
					console.log("No Metadata for: ", message, "Discarding Message.");
					//rollbacks.push(rollback);
					if (commit){
						commit();
					}
					processQueue(queue);
					return;
				}else {
					try {
						console.log("Index ID: ", message.id, "type: ", message.type);
						console.log("\tUser: ", message.user);
						console.log("Opts: ", message.options);
						var containerPaths=[];
						var fileDefs = [];
						var commitCollections=[];
						Object.keys(message.files).forEach(function(key){
							console.log("\tFiles[" + key + "]", message.files[key]);
							if (key != message.type) {
								commitCollections.push(key);
							}
							var files = message.files[key];
							if (!(files instanceof Array)) {
								files = [files];
							}
							files.forEach(function(file) {
								if (!file.path) { return; }
								console.log("File: ", file.name );
								console.log("PATH: ", file.path);
								var dir = Path.dirname(file.path);
								if (containerPaths.indexOf(dir)<0) {
									containerPaths.push(dir);
								}
								var def = new defer();
								fs.readJson(file.path, function(err,fileData){
									if (err){
										def.reject(err);
									}
									if (fileData && fileData.length<0) {
										console.log("Skipping Empty Data File: ", key, file.name,message.id);
										def.resolve(true);
										return;
									}	
									console.log("Records To index for  ",key, ": ", fileData.length,file.name);
								
									var processingErrors=false;	
									fileData = fileData.map(function(item){
										if (!item.public) { item.public=false; }
										if (!item.owner) { 
											item.owner = message.user;
										}else if (item.owner != message.user) {
											if (!item.user_write || (item.user_write && (item.user_write.indexOf(message.user)<0))){
												processingErrors="Item Owner ("+ item.owner+ ") !=  Index User (" + message.user+ ")";
											}
										}
									
										if (!item.user_read) { item.user_read = []; }
										if (!item.user_write) { item.user_write = []; }

										if (item._version_){
											delete item._version_;
										}
										return item;		
									});

									if (!processingErrors) {
										when(postDocs(fileData,key), function(results){
											def.resolve(true);
										}, function(err){
											console.log("Error POSTing documents to SOLR core : ",key, err);
											def.reject(err);
										});
									}else{
										console.log("Processing Errors in ", key, processingErrors);
										def.reject(processingErrors);
									}
							
								});
								fileDefs.push(def);
							});
						});

						when(All(fileDefs), function(){
							console.log("Container Paths: ", containerPaths);
							var commitDefs=[]
							commitCollections.forEach(function(col){
								commitDefs.push(solrCommit(col));
							});
							when(All(commitDefs), function(){
								when(solrCommit(message.type),function() {
									console.log("SOLR Collections to Commit: ", commitCollections);
									containerPaths.forEach(function(p){
										console.log("Removing files from : ", p);
										fs.removeSync(p);
									});
									commit();
									processQueue(queue);
								}, function(err){
									console.log("Error in final type commit: ", message.type, err);
									rollback();
								});
							}, function(err){
								console.log("Error in subtype commit: ", err);
								rollback();
							});
						}, function(err){
							console.log("Error Commiting Files..do roleback", err);
							rollback();
						});
					} catch (err){
						console.log("Error Indexing Data: ", err);
						rollback();
					}
				}
			});
		}
	});	
};





