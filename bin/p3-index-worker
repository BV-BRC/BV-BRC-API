#!/usr/bin/env node
var config = require("../config");
var Queue = require("file-queue").Queue;
var defer = require('promised-io/promise').defer;
var when = require('promised-io/promise').when;
var Path = require('path');
var fs = require("fs-extra");

console.log("Queue Directory: ", config.get("queueDirectory"));

var queue = new Queue(config.get("queueDirectory"), function(err) {
        if (err) {
                console.log("error: ", err);
                return;
        }
	processQueue(queue);
});

var maxLimit = config.get("indexImportLimits");

process.on('message', function(msg){
	if (msg && msg.type=="start"){
		if (timer) {
			cancelTimeout(timer);
			delete timer;
		}

		processQueue(queue);
	}
});
var timer;

var items = [];
var itemType;
var commitCallbacks=[];
var rollbacks = [];
function indexItems(){
	var def = new defer();

	console.log("Indexing Items.  Type:", itemType, " Item Count: ", items.length);

	commitCallbacks.forEach(function(cb){
		console.log("do commit")
		cb();
	});
	items = [];
	commitCallbacks=[];

	rollbacks.forEach(function(cb){
		console.log("do rollback")
		cb();
	});
	
	def.resolve(true);
	return def.promise;
}

function processQueue(queue){
	console.log("processQueue");
	queue.length(function(err,length){
		if (length < 1){
			setTimeout(function(){
				processQueue(queue);
			},5000);
			/*
			if (items.length>0){
				when(indexItems(),function(){
					setTimeout(function(){
						processQueue(queue);
					},0);
				});	
			}else if (rollbacks.length>0) {
				rollbacks.forEach(function(cb){
					console.log("do rollback")
					cb();
				});
				setTimeout(function(){
					processQueue(queue)
				},10000);
			}else{
				setTimeout(function(){
					processQueue(queue)
				},10000);
			}
			*/
		}else{
//			console.log("Processing " + length + " queue items");
		
			queue.tpop(function(err,message,commit,rollback){
				if (err) {
					console.log("error popping message item: ", err);
					return;
				}
				if (!message){
					console.log("No Metadata for: ", message, "Discarding Message.");
					//rollbacks.push(rollback);
					if (commit){
						commit();
					}
					processQueue(queue);
					return;
				}else {
					try {
						console.log("Index ID: ", message.id, "type: ", message.type);
						console.log("\tUser: ", message.user);
						console.log("Opts: ", message.options);
						var containerPaths=[];
						Object.keys(message.files).forEach(function(key){
							console.log("\tFiles[" + key + "]", message.files[key]);
							var files = message.files[key];
							if (!(files instanceof Array)) {
								files = [files];
							}
							files.forEach(function(file) {
								if (!file.path) { return; }
								console.log("File: ", file.name );
								console.log("PATH: ", file.path);
								var dir = Path.dirname(file.path);
								console.log("DIR: ", dir);
								if (containerPaths.indexOf(dir)<0) {
									containerPaths.push(dir);
								}
							});
						});
						console.log("Container Paths: ", containerPaths);

						containerPaths.forEach(function(p){
							console.log("Removing files from : ", p);
							fs.removeSync(p);
						});
						commit();
						processQueue(queue);
					} catch (err){
						console.log("Error Indexing Data: ", err);
						rollback();
					}
				}
			});
		}
	});	
};





